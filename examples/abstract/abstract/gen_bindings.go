// // Code generated by tsgo. DO NOT EDIT.
package main

/*
#include <stdlib.h>
static inline size_t float32Size() {
  return sizeof(float);
}

static inline size_t float64Size() {
  return sizeof(double);
}

static inline size_t int32Size() {
  return sizeof(int32_t);
}

static inline size_t int64Size() {
  return sizeof(int64_t);
}

static inline size_t uint32Size() {
  return sizeof(uint32_t);
}

static inline size_t uint64Size() {
  return sizeof(uint64_t);
}

*/
import "C"

import (
  "github.com/cryptodeal/tsgo/examples/abstract"
  "unsafe"
  "encoding/json"
  "fmt"
)

var ptrTrckr = make(map[uintptr]C.size_t)

//export disposePtr
func disposePtr(ptr unsafe.Pointer, ctx unsafe.Pointer) {
  ptr_num := uintptr(ptr)
  if _, ok := ptrTrckr[ptr_num]; ok {
    delete(ptrTrckr, ptr_num)
    defer C.free(ptr)
  }
}

//export ArraySize
func ArraySize(array unsafe.Pointer) C.size_t {
  return ptrTrckr[uintptr(array)]
}

func CFloat32(b []float32) unsafe.Pointer {
  p := C.malloc(C.size_t(len(b)) * C.float32Size())
  sliceHeader := struct {
    p   unsafe.Pointer
    len int
    cap int
  }{p, len(b), len(b)}
  s := *(*[]float32)(unsafe.Pointer(&sliceHeader))
  copy(s, b)
  return p
}

func CFloat64(b []float64) unsafe.Pointer {
  p := C.malloc(C.size_t(len(b)) * C.float64Size())
  sliceHeader := struct {
    p   unsafe.Pointer
    len int
    cap int
  }{p, len(b), len(b)}
  s := *(*[]float64)(unsafe.Pointer(&sliceHeader))
  copy(s, b)
  return p
}

func CInt32(b []int32) unsafe.Pointer {
  p := C.malloc(C.size_t(len(b)) * C.int32Size())
  sliceHeader := struct {
    p   unsafe.Pointer
    len int
    cap int
  }{p, len(b), len(b)}
  s := *(*[]int32)(unsafe.Pointer(&sliceHeader))
  copy(s, b)
  return p
}

func CInt64(b []int64) unsafe.Pointer {
  p := C.malloc(C.size_t(len(b)) * C.int64Size())
  sliceHeader := struct {
    p   unsafe.Pointer
    len int
    cap int
  }{p, len(b), len(b)}
  s := *(*[]int64)(unsafe.Pointer(&sliceHeader))
  copy(s, b)
  return p
}

func CUint32(b []uint32) unsafe.Pointer {
  p := C.malloc(C.size_t(len(b)) * C.uint32Size())
  sliceHeader := struct {
    p   unsafe.Pointer
    len int
    cap int
  }{p, len(b), len(b)}
  s := *(*[]uint32)(unsafe.Pointer(&sliceHeader))
  copy(s, b)
  return p
}

func CUint64(b []uint64) unsafe.Pointer {
  p := C.malloc(C.size_t(len(b)) * C.uint64Size())
  sliceHeader := struct {
    p   unsafe.Pointer
    len int
    cap int
  }{p, len(b), len(b)}
  s := *(*[]uint64)(unsafe.Pointer(&sliceHeader))
  copy(s, b)
  return p
}

func encodeJSON(x interface{}) []byte {
  res, err := json.Marshal(x)
  if err != nil {
    fmt.Println(err)
    panic(err)
  }
  return res
}

//export _IntTest
 func _IntTest (foo *C.char) C.int {
  _foo := C.GoString(foo)
  _returned_value := C.int(abstract.IntTest(_foo))
  return _returned_value
}

//export _Float32ArrayTest
 func _Float32ArrayTest (foo *C.char) unsafe.Pointer {
  _foo := C.GoString(foo)
  _returned_value := CFloat32(abstract.Float32ArrayTest(_foo))
  return _returned_value
}

//export _Float64ArrayTest
 func _Float64ArrayTest (foo *C.char) unsafe.Pointer {
  _foo := C.GoString(foo)
  _returned_value := CFloat64(abstract.Float64ArrayTest(_foo))
  return _returned_value
}

//export _Int32ArrayTest
 func _Int32ArrayTest (foo *C.char) unsafe.Pointer {
  _foo := C.GoString(foo)
  _returned_value := CInt32(abstract.Int32ArrayTest(_foo))
  return _returned_value
}

//export _Int64ArrayTest
 func _Int64ArrayTest (foo *C.char) unsafe.Pointer {
  _foo := C.GoString(foo)
  _returned_value := CInt64(abstract.Int64ArrayTest(_foo))
  return _returned_value
}

//export _Uint32ArrayTest
 func _Uint32ArrayTest (foo *C.char) unsafe.Pointer {
  _foo := C.GoString(foo)
  _returned_value := CUint32(abstract.Uint32ArrayTest(_foo))
  return _returned_value
}

//export _Uint64ArrayTest
 func _Uint64ArrayTest (foo *C.char) unsafe.Pointer {
  _foo := C.GoString(foo)
  _returned_value := CUint64(abstract.Uint64ArrayTest(_foo))
  return _returned_value
}

//export _TestStruct
 func _TestStruct () *C.char {
  _temp_res_val := encodeJSON(abstract.TestStruct())
  _returned_value := C.CString(string(_temp_res_val))
  defer C.free(unsafe.Pointer(_returned_value))
  return _returned_value
}

func main() {} // Required but ignored