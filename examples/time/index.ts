// Code generated by tsgo. DO NOT EDIT.

//////////
// source: format.go

/**
 * These are predefined layouts for use in Time.Format and time.Parse.
 * The reference time used in these layouts is the specific time stamp:
 * 	01/02 03:04:05PM '06 -0700
 * (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
 * That value is recorded as the constant named Layout, listed below. As a Unix
 * time, this is 1136239445. Since MST is GMT-0700, the reference would be
 * printed by the Unix date command as:
 * 	Mon Jan 2 15:04:05 MST 2006
 * It is a regrettable historic error that the date uses the American convention
 * of putting the numerical month before the day.
 * The example for Time.Format demonstrates the working of the layout string
 * in detail and is a good reference.
 * Note that the RFC822, RFC850, and RFC1123 formats should be applied
 * only to local times. Applying them to UTC times will use "UTC" as the
 * time zone abbreviation, while strictly speaking those RFCs require the
 * use of "GMT" in that case.
 * In general RFC1123Z should be used instead of RFC1123 for servers
 * that insist on that format, and RFC3339 should be preferred for new protocols.
 * RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
 * when used with time.Parse they do not accept all the time formats
 * permitted by the RFCs and they do accept time formats not formally defined.
 * The RFC3339Nano format removes trailing zeros from the seconds field
 * and thus may not sort correctly once formatted.
 * Most programs can use one of the defined constants as the layout passed to
 * Format or Parse. The rest of this comment can be ignored unless you are
 * creating a custom layout string.
 * To define your own format, write down what the reference time would look like
 * formatted your way; see the values of constants like ANSIC, StampMicro or
 * Kitchen for examples. The model is to demonstrate what the reference time
 * looks like so that the Format and Parse methods can apply the same
 * transformation to a general time value.
 * Here is a summary of the components of a layout string. Each element shows by
 * example the formatting of an element of the reference time. Only these values
 * are recognized. Text in the layout string that is not recognized as part of
 * the reference time is echoed verbatim during Format and expected to appear
 * verbatim in the input to Parse.
 * 	Year: "2006" "06"
 * 	Month: "Jan" "January" "01" "1"
 * 	Day of the week: "Mon" "Monday"
 * 	Day of the month: "2" "_2" "02"
 * 	Day of the year: "__2" "002"
 * 	Hour: "15" "3" "03" (PM or AM)
 * 	Minute: "4" "04"
 * 	Second: "5" "05"
 * 	AM/PM mark: "PM"
 * Numeric time zone offsets format as follows:
 * 	"-0700"     ±hhmm
 * 	"-07:00"    ±hh:mm
 * 	"-07"       ±hh
 * 	"-070000"   ±hhmmss
 * 	"-07:00:00" ±hh:mm:ss
 * Replacing the sign in the format with a Z triggers
 * the ISO 8601 behavior of printing Z instead of an
 * offset for the UTC zone. Thus:
 * 	"Z0700"      Z or ±hhmm
 * 	"Z07:00"     Z or ±hh:mm
 * 	"Z07"        Z or ±hh
 * 	"Z070000"    Z or ±hhmmss
 * 	"Z07:00:00"  Z or ±hh:mm:ss
 * Within the format string, the underscores in "_2" and "__2" represent spaces
 * that may be replaced by digits if the following number has multiple digits,
 * for compatibility with fixed-width Unix time formats. A leading zero represents
 * a zero-padded value.
 * The formats __2 and 002 are space-padded and zero-padded
 * three-character day of year; there is no unpadded day of year format.
 * A comma or decimal point followed by one or more zeros represents
 * a fractional second, printed to the given number of decimal places.
 * A comma or decimal point followed by one or more nines represents
 * a fractional second, printed to the given number of decimal places, with
 * trailing zeros removed.
 * For example "15:04:05,000" or "15:04:05.000" formats or parses with
 * millisecond precision.
 * Some valid layouts are invalid time values for time.Parse, due to formats
 * such as _ for space padding and Z for zone information.
 */
 = "01/02 03:04:05PM '06 -0700" // The reference time, in numerical order.
/**
 * These are predefined layouts for use in Time.Format and time.Parse.
 * The reference time used in these layouts is the specific time stamp:
 * 	01/02 03:04:05PM '06 -0700
 * (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
 * That value is recorded as the constant named Layout, listed below. As a Unix
 * time, this is 1136239445. Since MST is GMT-0700, the reference would be
 * printed by the Unix date command as:
 * 	Mon Jan 2 15:04:05 MST 2006
 * It is a regrettable historic error that the date uses the American convention
 * of putting the numerical month before the day.
 * The example for Time.Format demonstrates the working of the layout string
 * in detail and is a good reference.
 * Note that the RFC822, RFC850, and RFC1123 formats should be applied
 * only to local times. Applying them to UTC times will use "UTC" as the
 * time zone abbreviation, while strictly speaking those RFCs require the
 * use of "GMT" in that case.
 * In general RFC1123Z should be used instead of RFC1123 for servers
 * that insist on that format, and RFC3339 should be preferred for new protocols.
 * RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
 * when used with time.Parse they do not accept all the time formats
 * permitted by the RFCs and they do accept time formats not formally defined.
 * The RFC3339Nano format removes trailing zeros from the seconds field
 * and thus may not sort correctly once formatted.
 * Most programs can use one of the defined constants as the layout passed to
 * Format or Parse. The rest of this comment can be ignored unless you are
 * creating a custom layout string.
 * To define your own format, write down what the reference time would look like
 * formatted your way; see the values of constants like ANSIC, StampMicro or
 * Kitchen for examples. The model is to demonstrate what the reference time
 * looks like so that the Format and Parse methods can apply the same
 * transformation to a general time value.
 * Here is a summary of the components of a layout string. Each element shows by
 * example the formatting of an element of the reference time. Only these values
 * are recognized. Text in the layout string that is not recognized as part of
 * the reference time is echoed verbatim during Format and expected to appear
 * verbatim in the input to Parse.
 * 	Year: "2006" "06"
 * 	Month: "Jan" "January" "01" "1"
 * 	Day of the week: "Mon" "Monday"
 * 	Day of the month: "2" "_2" "02"
 * 	Day of the year: "__2" "002"
 * 	Hour: "15" "3" "03" (PM or AM)
 * 	Minute: "4" "04"
 * 	Second: "5" "05"
 * 	AM/PM mark: "PM"
 * Numeric time zone offsets format as follows:
 * 	"-0700"     ±hhmm
 * 	"-07:00"    ±hh:mm
 * 	"-07"       ±hh
 * 	"-070000"   ±hhmmss
 * 	"-07:00:00" ±hh:mm:ss
 * Replacing the sign in the format with a Z triggers
 * the ISO 8601 behavior of printing Z instead of an
 * offset for the UTC zone. Thus:
 * 	"Z0700"      Z or ±hhmm
 * 	"Z07:00"     Z or ±hh:mm
 * 	"Z07"        Z or ±hh
 * 	"Z070000"    Z or ±hhmmss
 * 	"Z07:00:00"  Z or ±hh:mm:ss
 * Within the format string, the underscores in "_2" and "__2" represent spaces
 * that may be replaced by digits if the following number has multiple digits,
 * for compatibility with fixed-width Unix time formats. A leading zero represents
 * a zero-padded value.
 * The formats __2 and 002 are space-padded and zero-padded
 * three-character day of year; there is no unpadded day of year format.
 * A comma or decimal point followed by one or more zeros represents
 * a fractional second, printed to the given number of decimal places.
 * A comma or decimal point followed by one or more nines represents
 * a fractional second, printed to the given number of decimal places, with
 * trailing zeros removed.
 * For example "15:04:05,000" or "15:04:05.000" formats or parses with
 * millisecond precision.
 * Some valid layouts are invalid time values for time.Parse, due to formats
 * such as _ for space padding and Z for zone information.
 */
 = "Mon Jan _2 15:04:05 2006"
/**
 * These are predefined layouts for use in Time.Format and time.Parse.
 * The reference time used in these layouts is the specific time stamp:
 * 	01/02 03:04:05PM '06 -0700
 * (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
 * That value is recorded as the constant named Layout, listed below. As a Unix
 * time, this is 1136239445. Since MST is GMT-0700, the reference would be
 * printed by the Unix date command as:
 * 	Mon Jan 2 15:04:05 MST 2006
 * It is a regrettable historic error that the date uses the American convention
 * of putting the numerical month before the day.
 * The example for Time.Format demonstrates the working of the layout string
 * in detail and is a good reference.
 * Note that the RFC822, RFC850, and RFC1123 formats should be applied
 * only to local times. Applying them to UTC times will use "UTC" as the
 * time zone abbreviation, while strictly speaking those RFCs require the
 * use of "GMT" in that case.
 * In general RFC1123Z should be used instead of RFC1123 for servers
 * that insist on that format, and RFC3339 should be preferred for new protocols.
 * RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
 * when used with time.Parse they do not accept all the time formats
 * permitted by the RFCs and they do accept time formats not formally defined.
 * The RFC3339Nano format removes trailing zeros from the seconds field
 * and thus may not sort correctly once formatted.
 * Most programs can use one of the defined constants as the layout passed to
 * Format or Parse. The rest of this comment can be ignored unless you are
 * creating a custom layout string.
 * To define your own format, write down what the reference time would look like
 * formatted your way; see the values of constants like ANSIC, StampMicro or
 * Kitchen for examples. The model is to demonstrate what the reference time
 * looks like so that the Format and Parse methods can apply the same
 * transformation to a general time value.
 * Here is a summary of the components of a layout string. Each element shows by
 * example the formatting of an element of the reference time. Only these values
 * are recognized. Text in the layout string that is not recognized as part of
 * the reference time is echoed verbatim during Format and expected to appear
 * verbatim in the input to Parse.
 * 	Year: "2006" "06"
 * 	Month: "Jan" "January" "01" "1"
 * 	Day of the week: "Mon" "Monday"
 * 	Day of the month: "2" "_2" "02"
 * 	Day of the year: "__2" "002"
 * 	Hour: "15" "3" "03" (PM or AM)
 * 	Minute: "4" "04"
 * 	Second: "5" "05"
 * 	AM/PM mark: "PM"
 * Numeric time zone offsets format as follows:
 * 	"-0700"     ±hhmm
 * 	"-07:00"    ±hh:mm
 * 	"-07"       ±hh
 * 	"-070000"   ±hhmmss
 * 	"-07:00:00" ±hh:mm:ss
 * Replacing the sign in the format with a Z triggers
 * the ISO 8601 behavior of printing Z instead of an
 * offset for the UTC zone. Thus:
 * 	"Z0700"      Z or ±hhmm
 * 	"Z07:00"     Z or ±hh:mm
 * 	"Z07"        Z or ±hh
 * 	"Z070000"    Z or ±hhmmss
 * 	"Z07:00:00"  Z or ±hh:mm:ss
 * Within the format string, the underscores in "_2" and "__2" represent spaces
 * that may be replaced by digits if the following number has multiple digits,
 * for compatibility with fixed-width Unix time formats. A leading zero represents
 * a zero-padded value.
 * The formats __2 and 002 are space-padded and zero-padded
 * three-character day of year; there is no unpadded day of year format.
 * A comma or decimal point followed by one or more zeros represents
 * a fractional second, printed to the given number of decimal places.
 * A comma or decimal point followed by one or more nines represents
 * a fractional second, printed to the given number of decimal places, with
 * trailing zeros removed.
 * For example "15:04:05,000" or "15:04:05.000" formats or parses with
 * millisecond precision.
 * Some valid layouts are invalid time values for time.Parse, due to formats
 * such as _ for space padding and Z for zone information.
 */
 = "Mon Jan _2 15:04:05 MST 2006"
/**
 * These are predefined layouts for use in Time.Format and time.Parse.
 * The reference time used in these layouts is the specific time stamp:
 * 	01/02 03:04:05PM '06 -0700
 * (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
 * That value is recorded as the constant named Layout, listed below. As a Unix
 * time, this is 1136239445. Since MST is GMT-0700, the reference would be
 * printed by the Unix date command as:
 * 	Mon Jan 2 15:04:05 MST 2006
 * It is a regrettable historic error that the date uses the American convention
 * of putting the numerical month before the day.
 * The example for Time.Format demonstrates the working of the layout string
 * in detail and is a good reference.
 * Note that the RFC822, RFC850, and RFC1123 formats should be applied
 * only to local times. Applying them to UTC times will use "UTC" as the
 * time zone abbreviation, while strictly speaking those RFCs require the
 * use of "GMT" in that case.
 * In general RFC1123Z should be used instead of RFC1123 for servers
 * that insist on that format, and RFC3339 should be preferred for new protocols.
 * RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
 * when used with time.Parse they do not accept all the time formats
 * permitted by the RFCs and they do accept time formats not formally defined.
 * The RFC3339Nano format removes trailing zeros from the seconds field
 * and thus may not sort correctly once formatted.
 * Most programs can use one of the defined constants as the layout passed to
 * Format or Parse. The rest of this comment can be ignored unless you are
 * creating a custom layout string.
 * To define your own format, write down what the reference time would look like
 * formatted your way; see the values of constants like ANSIC, StampMicro or
 * Kitchen for examples. The model is to demonstrate what the reference time
 * looks like so that the Format and Parse methods can apply the same
 * transformation to a general time value.
 * Here is a summary of the components of a layout string. Each element shows by
 * example the formatting of an element of the reference time. Only these values
 * are recognized. Text in the layout string that is not recognized as part of
 * the reference time is echoed verbatim during Format and expected to appear
 * verbatim in the input to Parse.
 * 	Year: "2006" "06"
 * 	Month: "Jan" "January" "01" "1"
 * 	Day of the week: "Mon" "Monday"
 * 	Day of the month: "2" "_2" "02"
 * 	Day of the year: "__2" "002"
 * 	Hour: "15" "3" "03" (PM or AM)
 * 	Minute: "4" "04"
 * 	Second: "5" "05"
 * 	AM/PM mark: "PM"
 * Numeric time zone offsets format as follows:
 * 	"-0700"     ±hhmm
 * 	"-07:00"    ±hh:mm
 * 	"-07"       ±hh
 * 	"-070000"   ±hhmmss
 * 	"-07:00:00" ±hh:mm:ss
 * Replacing the sign in the format with a Z triggers
 * the ISO 8601 behavior of printing Z instead of an
 * offset for the UTC zone. Thus:
 * 	"Z0700"      Z or ±hhmm
 * 	"Z07:00"     Z or ±hh:mm
 * 	"Z07"        Z or ±hh
 * 	"Z070000"    Z or ±hhmmss
 * 	"Z07:00:00"  Z or ±hh:mm:ss
 * Within the format string, the underscores in "_2" and "__2" represent spaces
 * that may be replaced by digits if the following number has multiple digits,
 * for compatibility with fixed-width Unix time formats. A leading zero represents
 * a zero-padded value.
 * The formats __2 and 002 are space-padded and zero-padded
 * three-character day of year; there is no unpadded day of year format.
 * A comma or decimal point followed by one or more zeros represents
 * a fractional second, printed to the given number of decimal places.
 * A comma or decimal point followed by one or more nines represents
 * a fractional second, printed to the given number of decimal places, with
 * trailing zeros removed.
 * For example "15:04:05,000" or "15:04:05.000" formats or parses with
 * millisecond precision.
 * Some valid layouts are invalid time values for time.Parse, due to formats
 * such as _ for space padding and Z for zone information.
 */
 = "Mon Jan 02 15:04:05 -0700 2006"
/**
 * These are predefined layouts for use in Time.Format and time.Parse.
 * The reference time used in these layouts is the specific time stamp:
 * 	01/02 03:04:05PM '06 -0700
 * (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
 * That value is recorded as the constant named Layout, listed below. As a Unix
 * time, this is 1136239445. Since MST is GMT-0700, the reference would be
 * printed by the Unix date command as:
 * 	Mon Jan 2 15:04:05 MST 2006
 * It is a regrettable historic error that the date uses the American convention
 * of putting the numerical month before the day.
 * The example for Time.Format demonstrates the working of the layout string
 * in detail and is a good reference.
 * Note that the RFC822, RFC850, and RFC1123 formats should be applied
 * only to local times. Applying them to UTC times will use "UTC" as the
 * time zone abbreviation, while strictly speaking those RFCs require the
 * use of "GMT" in that case.
 * In general RFC1123Z should be used instead of RFC1123 for servers
 * that insist on that format, and RFC3339 should be preferred for new protocols.
 * RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
 * when used with time.Parse they do not accept all the time formats
 * permitted by the RFCs and they do accept time formats not formally defined.
 * The RFC3339Nano format removes trailing zeros from the seconds field
 * and thus may not sort correctly once formatted.
 * Most programs can use one of the defined constants as the layout passed to
 * Format or Parse. The rest of this comment can be ignored unless you are
 * creating a custom layout string.
 * To define your own format, write down what the reference time would look like
 * formatted your way; see the values of constants like ANSIC, StampMicro or
 * Kitchen for examples. The model is to demonstrate what the reference time
 * looks like so that the Format and Parse methods can apply the same
 * transformation to a general time value.
 * Here is a summary of the components of a layout string. Each element shows by
 * example the formatting of an element of the reference time. Only these values
 * are recognized. Text in the layout string that is not recognized as part of
 * the reference time is echoed verbatim during Format and expected to appear
 * verbatim in the input to Parse.
 * 	Year: "2006" "06"
 * 	Month: "Jan" "January" "01" "1"
 * 	Day of the week: "Mon" "Monday"
 * 	Day of the month: "2" "_2" "02"
 * 	Day of the year: "__2" "002"
 * 	Hour: "15" "3" "03" (PM or AM)
 * 	Minute: "4" "04"
 * 	Second: "5" "05"
 * 	AM/PM mark: "PM"
 * Numeric time zone offsets format as follows:
 * 	"-0700"     ±hhmm
 * 	"-07:00"    ±hh:mm
 * 	"-07"       ±hh
 * 	"-070000"   ±hhmmss
 * 	"-07:00:00" ±hh:mm:ss
 * Replacing the sign in the format with a Z triggers
 * the ISO 8601 behavior of printing Z instead of an
 * offset for the UTC zone. Thus:
 * 	"Z0700"      Z or ±hhmm
 * 	"Z07:00"     Z or ±hh:mm
 * 	"Z07"        Z or ±hh
 * 	"Z070000"    Z or ±hhmmss
 * 	"Z07:00:00"  Z or ±hh:mm:ss
 * Within the format string, the underscores in "_2" and "__2" represent spaces
 * that may be replaced by digits if the following number has multiple digits,
 * for compatibility with fixed-width Unix time formats. A leading zero represents
 * a zero-padded value.
 * The formats __2 and 002 are space-padded and zero-padded
 * three-character day of year; there is no unpadded day of year format.
 * A comma or decimal point followed by one or more zeros represents
 * a fractional second, printed to the given number of decimal places.
 * A comma or decimal point followed by one or more nines represents
 * a fractional second, printed to the given number of decimal places, with
 * trailing zeros removed.
 * For example "15:04:05,000" or "15:04:05.000" formats or parses with
 * millisecond precision.
 * Some valid layouts are invalid time values for time.Parse, due to formats
 * such as _ for space padding and Z for zone information.
 */
 = "02 Jan 06 15:04 MST"
/**
 * These are predefined layouts for use in Time.Format and time.Parse.
 * The reference time used in these layouts is the specific time stamp:
 * 	01/02 03:04:05PM '06 -0700
 * (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
 * That value is recorded as the constant named Layout, listed below. As a Unix
 * time, this is 1136239445. Since MST is GMT-0700, the reference would be
 * printed by the Unix date command as:
 * 	Mon Jan 2 15:04:05 MST 2006
 * It is a regrettable historic error that the date uses the American convention
 * of putting the numerical month before the day.
 * The example for Time.Format demonstrates the working of the layout string
 * in detail and is a good reference.
 * Note that the RFC822, RFC850, and RFC1123 formats should be applied
 * only to local times. Applying them to UTC times will use "UTC" as the
 * time zone abbreviation, while strictly speaking those RFCs require the
 * use of "GMT" in that case.
 * In general RFC1123Z should be used instead of RFC1123 for servers
 * that insist on that format, and RFC3339 should be preferred for new protocols.
 * RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
 * when used with time.Parse they do not accept all the time formats
 * permitted by the RFCs and they do accept time formats not formally defined.
 * The RFC3339Nano format removes trailing zeros from the seconds field
 * and thus may not sort correctly once formatted.
 * Most programs can use one of the defined constants as the layout passed to
 * Format or Parse. The rest of this comment can be ignored unless you are
 * creating a custom layout string.
 * To define your own format, write down what the reference time would look like
 * formatted your way; see the values of constants like ANSIC, StampMicro or
 * Kitchen for examples. The model is to demonstrate what the reference time
 * looks like so that the Format and Parse methods can apply the same
 * transformation to a general time value.
 * Here is a summary of the components of a layout string. Each element shows by
 * example the formatting of an element of the reference time. Only these values
 * are recognized. Text in the layout string that is not recognized as part of
 * the reference time is echoed verbatim during Format and expected to appear
 * verbatim in the input to Parse.
 * 	Year: "2006" "06"
 * 	Month: "Jan" "January" "01" "1"
 * 	Day of the week: "Mon" "Monday"
 * 	Day of the month: "2" "_2" "02"
 * 	Day of the year: "__2" "002"
 * 	Hour: "15" "3" "03" (PM or AM)
 * 	Minute: "4" "04"
 * 	Second: "5" "05"
 * 	AM/PM mark: "PM"
 * Numeric time zone offsets format as follows:
 * 	"-0700"     ±hhmm
 * 	"-07:00"    ±hh:mm
 * 	"-07"       ±hh
 * 	"-070000"   ±hhmmss
 * 	"-07:00:00" ±hh:mm:ss
 * Replacing the sign in the format with a Z triggers
 * the ISO 8601 behavior of printing Z instead of an
 * offset for the UTC zone. Thus:
 * 	"Z0700"      Z or ±hhmm
 * 	"Z07:00"     Z or ±hh:mm
 * 	"Z07"        Z or ±hh
 * 	"Z070000"    Z or ±hhmmss
 * 	"Z07:00:00"  Z or ±hh:mm:ss
 * Within the format string, the underscores in "_2" and "__2" represent spaces
 * that may be replaced by digits if the following number has multiple digits,
 * for compatibility with fixed-width Unix time formats. A leading zero represents
 * a zero-padded value.
 * The formats __2 and 002 are space-padded and zero-padded
 * three-character day of year; there is no unpadded day of year format.
 * A comma or decimal point followed by one or more zeros represents
 * a fractional second, printed to the given number of decimal places.
 * A comma or decimal point followed by one or more nines represents
 * a fractional second, printed to the given number of decimal places, with
 * trailing zeros removed.
 * For example "15:04:05,000" or "15:04:05.000" formats or parses with
 * millisecond precision.
 * Some valid layouts are invalid time values for time.Parse, due to formats
 * such as _ for space padding and Z for zone information.
 */
 = "02 Jan 06 15:04 -0700" // RFC822 with numeric zone
/**
 * These are predefined layouts for use in Time.Format and time.Parse.
 * The reference time used in these layouts is the specific time stamp:
 * 	01/02 03:04:05PM '06 -0700
 * (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
 * That value is recorded as the constant named Layout, listed below. As a Unix
 * time, this is 1136239445. Since MST is GMT-0700, the reference would be
 * printed by the Unix date command as:
 * 	Mon Jan 2 15:04:05 MST 2006
 * It is a regrettable historic error that the date uses the American convention
 * of putting the numerical month before the day.
 * The example for Time.Format demonstrates the working of the layout string
 * in detail and is a good reference.
 * Note that the RFC822, RFC850, and RFC1123 formats should be applied
 * only to local times. Applying them to UTC times will use "UTC" as the
 * time zone abbreviation, while strictly speaking those RFCs require the
 * use of "GMT" in that case.
 * In general RFC1123Z should be used instead of RFC1123 for servers
 * that insist on that format, and RFC3339 should be preferred for new protocols.
 * RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
 * when used with time.Parse they do not accept all the time formats
 * permitted by the RFCs and they do accept time formats not formally defined.
 * The RFC3339Nano format removes trailing zeros from the seconds field
 * and thus may not sort correctly once formatted.
 * Most programs can use one of the defined constants as the layout passed to
 * Format or Parse. The rest of this comment can be ignored unless you are
 * creating a custom layout string.
 * To define your own format, write down what the reference time would look like
 * formatted your way; see the values of constants like ANSIC, StampMicro or
 * Kitchen for examples. The model is to demonstrate what the reference time
 * looks like so that the Format and Parse methods can apply the same
 * transformation to a general time value.
 * Here is a summary of the components of a layout string. Each element shows by
 * example the formatting of an element of the reference time. Only these values
 * are recognized. Text in the layout string that is not recognized as part of
 * the reference time is echoed verbatim during Format and expected to appear
 * verbatim in the input to Parse.
 * 	Year: "2006" "06"
 * 	Month: "Jan" "January" "01" "1"
 * 	Day of the week: "Mon" "Monday"
 * 	Day of the month: "2" "_2" "02"
 * 	Day of the year: "__2" "002"
 * 	Hour: "15" "3" "03" (PM or AM)
 * 	Minute: "4" "04"
 * 	Second: "5" "05"
 * 	AM/PM mark: "PM"
 * Numeric time zone offsets format as follows:
 * 	"-0700"     ±hhmm
 * 	"-07:00"    ±hh:mm
 * 	"-07"       ±hh
 * 	"-070000"   ±hhmmss
 * 	"-07:00:00" ±hh:mm:ss
 * Replacing the sign in the format with a Z triggers
 * the ISO 8601 behavior of printing Z instead of an
 * offset for the UTC zone. Thus:
 * 	"Z0700"      Z or ±hhmm
 * 	"Z07:00"     Z or ±hh:mm
 * 	"Z07"        Z or ±hh
 * 	"Z070000"    Z or ±hhmmss
 * 	"Z07:00:00"  Z or ±hh:mm:ss
 * Within the format string, the underscores in "_2" and "__2" represent spaces
 * that may be replaced by digits if the following number has multiple digits,
 * for compatibility with fixed-width Unix time formats. A leading zero represents
 * a zero-padded value.
 * The formats __2 and 002 are space-padded and zero-padded
 * three-character day of year; there is no unpadded day of year format.
 * A comma or decimal point followed by one or more zeros represents
 * a fractional second, printed to the given number of decimal places.
 * A comma or decimal point followed by one or more nines represents
 * a fractional second, printed to the given number of decimal places, with
 * trailing zeros removed.
 * For example "15:04:05,000" or "15:04:05.000" formats or parses with
 * millisecond precision.
 * Some valid layouts are invalid time values for time.Parse, due to formats
 * such as _ for space padding and Z for zone information.
 */
 = "Monday, 02-Jan-06 15:04:05 MST"
/**
 * These are predefined layouts for use in Time.Format and time.Parse.
 * The reference time used in these layouts is the specific time stamp:
 * 	01/02 03:04:05PM '06 -0700
 * (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
 * That value is recorded as the constant named Layout, listed below. As a Unix
 * time, this is 1136239445. Since MST is GMT-0700, the reference would be
 * printed by the Unix date command as:
 * 	Mon Jan 2 15:04:05 MST 2006
 * It is a regrettable historic error that the date uses the American convention
 * of putting the numerical month before the day.
 * The example for Time.Format demonstrates the working of the layout string
 * in detail and is a good reference.
 * Note that the RFC822, RFC850, and RFC1123 formats should be applied
 * only to local times. Applying them to UTC times will use "UTC" as the
 * time zone abbreviation, while strictly speaking those RFCs require the
 * use of "GMT" in that case.
 * In general RFC1123Z should be used instead of RFC1123 for servers
 * that insist on that format, and RFC3339 should be preferred for new protocols.
 * RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
 * when used with time.Parse they do not accept all the time formats
 * permitted by the RFCs and they do accept time formats not formally defined.
 * The RFC3339Nano format removes trailing zeros from the seconds field
 * and thus may not sort correctly once formatted.
 * Most programs can use one of the defined constants as the layout passed to
 * Format or Parse. The rest of this comment can be ignored unless you are
 * creating a custom layout string.
 * To define your own format, write down what the reference time would look like
 * formatted your way; see the values of constants like ANSIC, StampMicro or
 * Kitchen for examples. The model is to demonstrate what the reference time
 * looks like so that the Format and Parse methods can apply the same
 * transformation to a general time value.
 * Here is a summary of the components of a layout string. Each element shows by
 * example the formatting of an element of the reference time. Only these values
 * are recognized. Text in the layout string that is not recognized as part of
 * the reference time is echoed verbatim during Format and expected to appear
 * verbatim in the input to Parse.
 * 	Year: "2006" "06"
 * 	Month: "Jan" "January" "01" "1"
 * 	Day of the week: "Mon" "Monday"
 * 	Day of the month: "2" "_2" "02"
 * 	Day of the year: "__2" "002"
 * 	Hour: "15" "3" "03" (PM or AM)
 * 	Minute: "4" "04"
 * 	Second: "5" "05"
 * 	AM/PM mark: "PM"
 * Numeric time zone offsets format as follows:
 * 	"-0700"     ±hhmm
 * 	"-07:00"    ±hh:mm
 * 	"-07"       ±hh
 * 	"-070000"   ±hhmmss
 * 	"-07:00:00" ±hh:mm:ss
 * Replacing the sign in the format with a Z triggers
 * the ISO 8601 behavior of printing Z instead of an
 * offset for the UTC zone. Thus:
 * 	"Z0700"      Z or ±hhmm
 * 	"Z07:00"     Z or ±hh:mm
 * 	"Z07"        Z or ±hh
 * 	"Z070000"    Z or ±hhmmss
 * 	"Z07:00:00"  Z or ±hh:mm:ss
 * Within the format string, the underscores in "_2" and "__2" represent spaces
 * that may be replaced by digits if the following number has multiple digits,
 * for compatibility with fixed-width Unix time formats. A leading zero represents
 * a zero-padded value.
 * The formats __2 and 002 are space-padded and zero-padded
 * three-character day of year; there is no unpadded day of year format.
 * A comma or decimal point followed by one or more zeros represents
 * a fractional second, printed to the given number of decimal places.
 * A comma or decimal point followed by one or more nines represents
 * a fractional second, printed to the given number of decimal places, with
 * trailing zeros removed.
 * For example "15:04:05,000" or "15:04:05.000" formats or parses with
 * millisecond precision.
 * Some valid layouts are invalid time values for time.Parse, due to formats
 * such as _ for space padding and Z for zone information.
 */
 = "Mon, 02 Jan 2006 15:04:05 MST"
/**
 * These are predefined layouts for use in Time.Format and time.Parse.
 * The reference time used in these layouts is the specific time stamp:
 * 	01/02 03:04:05PM '06 -0700
 * (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
 * That value is recorded as the constant named Layout, listed below. As a Unix
 * time, this is 1136239445. Since MST is GMT-0700, the reference would be
 * printed by the Unix date command as:
 * 	Mon Jan 2 15:04:05 MST 2006
 * It is a regrettable historic error that the date uses the American convention
 * of putting the numerical month before the day.
 * The example for Time.Format demonstrates the working of the layout string
 * in detail and is a good reference.
 * Note that the RFC822, RFC850, and RFC1123 formats should be applied
 * only to local times. Applying them to UTC times will use "UTC" as the
 * time zone abbreviation, while strictly speaking those RFCs require the
 * use of "GMT" in that case.
 * In general RFC1123Z should be used instead of RFC1123 for servers
 * that insist on that format, and RFC3339 should be preferred for new protocols.
 * RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
 * when used with time.Parse they do not accept all the time formats
 * permitted by the RFCs and they do accept time formats not formally defined.
 * The RFC3339Nano format removes trailing zeros from the seconds field
 * and thus may not sort correctly once formatted.
 * Most programs can use one of the defined constants as the layout passed to
 * Format or Parse. The rest of this comment can be ignored unless you are
 * creating a custom layout string.
 * To define your own format, write down what the reference time would look like
 * formatted your way; see the values of constants like ANSIC, StampMicro or
 * Kitchen for examples. The model is to demonstrate what the reference time
 * looks like so that the Format and Parse methods can apply the same
 * transformation to a general time value.
 * Here is a summary of the components of a layout string. Each element shows by
 * example the formatting of an element of the reference time. Only these values
 * are recognized. Text in the layout string that is not recognized as part of
 * the reference time is echoed verbatim during Format and expected to appear
 * verbatim in the input to Parse.
 * 	Year: "2006" "06"
 * 	Month: "Jan" "January" "01" "1"
 * 	Day of the week: "Mon" "Monday"
 * 	Day of the month: "2" "_2" "02"
 * 	Day of the year: "__2" "002"
 * 	Hour: "15" "3" "03" (PM or AM)
 * 	Minute: "4" "04"
 * 	Second: "5" "05"
 * 	AM/PM mark: "PM"
 * Numeric time zone offsets format as follows:
 * 	"-0700"     ±hhmm
 * 	"-07:00"    ±hh:mm
 * 	"-07"       ±hh
 * 	"-070000"   ±hhmmss
 * 	"-07:00:00" ±hh:mm:ss
 * Replacing the sign in the format with a Z triggers
 * the ISO 8601 behavior of printing Z instead of an
 * offset for the UTC zone. Thus:
 * 	"Z0700"      Z or ±hhmm
 * 	"Z07:00"     Z or ±hh:mm
 * 	"Z07"        Z or ±hh
 * 	"Z070000"    Z or ±hhmmss
 * 	"Z07:00:00"  Z or ±hh:mm:ss
 * Within the format string, the underscores in "_2" and "__2" represent spaces
 * that may be replaced by digits if the following number has multiple digits,
 * for compatibility with fixed-width Unix time formats. A leading zero represents
 * a zero-padded value.
 * The formats __2 and 002 are space-padded and zero-padded
 * three-character day of year; there is no unpadded day of year format.
 * A comma or decimal point followed by one or more zeros represents
 * a fractional second, printed to the given number of decimal places.
 * A comma or decimal point followed by one or more nines represents
 * a fractional second, printed to the given number of decimal places, with
 * trailing zeros removed.
 * For example "15:04:05,000" or "15:04:05.000" formats or parses with
 * millisecond precision.
 * Some valid layouts are invalid time values for time.Parse, due to formats
 * such as _ for space padding and Z for zone information.
 */
 = "Mon, 02 Jan 2006 15:04:05 -0700" // RFC1123 with numeric zone
/**
 * These are predefined layouts for use in Time.Format and time.Parse.
 * The reference time used in these layouts is the specific time stamp:
 * 	01/02 03:04:05PM '06 -0700
 * (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
 * That value is recorded as the constant named Layout, listed below. As a Unix
 * time, this is 1136239445. Since MST is GMT-0700, the reference would be
 * printed by the Unix date command as:
 * 	Mon Jan 2 15:04:05 MST 2006
 * It is a regrettable historic error that the date uses the American convention
 * of putting the numerical month before the day.
 * The example for Time.Format demonstrates the working of the layout string
 * in detail and is a good reference.
 * Note that the RFC822, RFC850, and RFC1123 formats should be applied
 * only to local times. Applying them to UTC times will use "UTC" as the
 * time zone abbreviation, while strictly speaking those RFCs require the
 * use of "GMT" in that case.
 * In general RFC1123Z should be used instead of RFC1123 for servers
 * that insist on that format, and RFC3339 should be preferred for new protocols.
 * RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
 * when used with time.Parse they do not accept all the time formats
 * permitted by the RFCs and they do accept time formats not formally defined.
 * The RFC3339Nano format removes trailing zeros from the seconds field
 * and thus may not sort correctly once formatted.
 * Most programs can use one of the defined constants as the layout passed to
 * Format or Parse. The rest of this comment can be ignored unless you are
 * creating a custom layout string.
 * To define your own format, write down what the reference time would look like
 * formatted your way; see the values of constants like ANSIC, StampMicro or
 * Kitchen for examples. The model is to demonstrate what the reference time
 * looks like so that the Format and Parse methods can apply the same
 * transformation to a general time value.
 * Here is a summary of the components of a layout string. Each element shows by
 * example the formatting of an element of the reference time. Only these values
 * are recognized. Text in the layout string that is not recognized as part of
 * the reference time is echoed verbatim during Format and expected to appear
 * verbatim in the input to Parse.
 * 	Year: "2006" "06"
 * 	Month: "Jan" "January" "01" "1"
 * 	Day of the week: "Mon" "Monday"
 * 	Day of the month: "2" "_2" "02"
 * 	Day of the year: "__2" "002"
 * 	Hour: "15" "3" "03" (PM or AM)
 * 	Minute: "4" "04"
 * 	Second: "5" "05"
 * 	AM/PM mark: "PM"
 * Numeric time zone offsets format as follows:
 * 	"-0700"     ±hhmm
 * 	"-07:00"    ±hh:mm
 * 	"-07"       ±hh
 * 	"-070000"   ±hhmmss
 * 	"-07:00:00" ±hh:mm:ss
 * Replacing the sign in the format with a Z triggers
 * the ISO 8601 behavior of printing Z instead of an
 * offset for the UTC zone. Thus:
 * 	"Z0700"      Z or ±hhmm
 * 	"Z07:00"     Z or ±hh:mm
 * 	"Z07"        Z or ±hh
 * 	"Z070000"    Z or ±hhmmss
 * 	"Z07:00:00"  Z or ±hh:mm:ss
 * Within the format string, the underscores in "_2" and "__2" represent spaces
 * that may be replaced by digits if the following number has multiple digits,
 * for compatibility with fixed-width Unix time formats. A leading zero represents
 * a zero-padded value.
 * The formats __2 and 002 are space-padded and zero-padded
 * three-character day of year; there is no unpadded day of year format.
 * A comma or decimal point followed by one or more zeros represents
 * a fractional second, printed to the given number of decimal places.
 * A comma or decimal point followed by one or more nines represents
 * a fractional second, printed to the given number of decimal places, with
 * trailing zeros removed.
 * For example "15:04:05,000" or "15:04:05.000" formats or parses with
 * millisecond precision.
 * Some valid layouts are invalid time values for time.Parse, due to formats
 * such as _ for space padding and Z for zone information.
 */
 = "2006-01-02T15:04:05Z07:00"
/**
 * These are predefined layouts for use in Time.Format and time.Parse.
 * The reference time used in these layouts is the specific time stamp:
 * 	01/02 03:04:05PM '06 -0700
 * (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
 * That value is recorded as the constant named Layout, listed below. As a Unix
 * time, this is 1136239445. Since MST is GMT-0700, the reference would be
 * printed by the Unix date command as:
 * 	Mon Jan 2 15:04:05 MST 2006
 * It is a regrettable historic error that the date uses the American convention
 * of putting the numerical month before the day.
 * The example for Time.Format demonstrates the working of the layout string
 * in detail and is a good reference.
 * Note that the RFC822, RFC850, and RFC1123 formats should be applied
 * only to local times. Applying them to UTC times will use "UTC" as the
 * time zone abbreviation, while strictly speaking those RFCs require the
 * use of "GMT" in that case.
 * In general RFC1123Z should be used instead of RFC1123 for servers
 * that insist on that format, and RFC3339 should be preferred for new protocols.
 * RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
 * when used with time.Parse they do not accept all the time formats
 * permitted by the RFCs and they do accept time formats not formally defined.
 * The RFC3339Nano format removes trailing zeros from the seconds field
 * and thus may not sort correctly once formatted.
 * Most programs can use one of the defined constants as the layout passed to
 * Format or Parse. The rest of this comment can be ignored unless you are
 * creating a custom layout string.
 * To define your own format, write down what the reference time would look like
 * formatted your way; see the values of constants like ANSIC, StampMicro or
 * Kitchen for examples. The model is to demonstrate what the reference time
 * looks like so that the Format and Parse methods can apply the same
 * transformation to a general time value.
 * Here is a summary of the components of a layout string. Each element shows by
 * example the formatting of an element of the reference time. Only these values
 * are recognized. Text in the layout string that is not recognized as part of
 * the reference time is echoed verbatim during Format and expected to appear
 * verbatim in the input to Parse.
 * 	Year: "2006" "06"
 * 	Month: "Jan" "January" "01" "1"
 * 	Day of the week: "Mon" "Monday"
 * 	Day of the month: "2" "_2" "02"
 * 	Day of the year: "__2" "002"
 * 	Hour: "15" "3" "03" (PM or AM)
 * 	Minute: "4" "04"
 * 	Second: "5" "05"
 * 	AM/PM mark: "PM"
 * Numeric time zone offsets format as follows:
 * 	"-0700"     ±hhmm
 * 	"-07:00"    ±hh:mm
 * 	"-07"       ±hh
 * 	"-070000"   ±hhmmss
 * 	"-07:00:00" ±hh:mm:ss
 * Replacing the sign in the format with a Z triggers
 * the ISO 8601 behavior of printing Z instead of an
 * offset for the UTC zone. Thus:
 * 	"Z0700"      Z or ±hhmm
 * 	"Z07:00"     Z or ±hh:mm
 * 	"Z07"        Z or ±hh
 * 	"Z070000"    Z or ±hhmmss
 * 	"Z07:00:00"  Z or ±hh:mm:ss
 * Within the format string, the underscores in "_2" and "__2" represent spaces
 * that may be replaced by digits if the following number has multiple digits,
 * for compatibility with fixed-width Unix time formats. A leading zero represents
 * a zero-padded value.
 * The formats __2 and 002 are space-padded and zero-padded
 * three-character day of year; there is no unpadded day of year format.
 * A comma or decimal point followed by one or more zeros represents
 * a fractional second, printed to the given number of decimal places.
 * A comma or decimal point followed by one or more nines represents
 * a fractional second, printed to the given number of decimal places, with
 * trailing zeros removed.
 * For example "15:04:05,000" or "15:04:05.000" formats or parses with
 * millisecond precision.
 * Some valid layouts are invalid time values for time.Parse, due to formats
 * such as _ for space padding and Z for zone information.
 */
 = "2006-01-02T15:04:05.999999999Z07:00"
/**
 * These are predefined layouts for use in Time.Format and time.Parse.
 * The reference time used in these layouts is the specific time stamp:
 * 	01/02 03:04:05PM '06 -0700
 * (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
 * That value is recorded as the constant named Layout, listed below. As a Unix
 * time, this is 1136239445. Since MST is GMT-0700, the reference would be
 * printed by the Unix date command as:
 * 	Mon Jan 2 15:04:05 MST 2006
 * It is a regrettable historic error that the date uses the American convention
 * of putting the numerical month before the day.
 * The example for Time.Format demonstrates the working of the layout string
 * in detail and is a good reference.
 * Note that the RFC822, RFC850, and RFC1123 formats should be applied
 * only to local times. Applying them to UTC times will use "UTC" as the
 * time zone abbreviation, while strictly speaking those RFCs require the
 * use of "GMT" in that case.
 * In general RFC1123Z should be used instead of RFC1123 for servers
 * that insist on that format, and RFC3339 should be preferred for new protocols.
 * RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
 * when used with time.Parse they do not accept all the time formats
 * permitted by the RFCs and they do accept time formats not formally defined.
 * The RFC3339Nano format removes trailing zeros from the seconds field
 * and thus may not sort correctly once formatted.
 * Most programs can use one of the defined constants as the layout passed to
 * Format or Parse. The rest of this comment can be ignored unless you are
 * creating a custom layout string.
 * To define your own format, write down what the reference time would look like
 * formatted your way; see the values of constants like ANSIC, StampMicro or
 * Kitchen for examples. The model is to demonstrate what the reference time
 * looks like so that the Format and Parse methods can apply the same
 * transformation to a general time value.
 * Here is a summary of the components of a layout string. Each element shows by
 * example the formatting of an element of the reference time. Only these values
 * are recognized. Text in the layout string that is not recognized as part of
 * the reference time is echoed verbatim during Format and expected to appear
 * verbatim in the input to Parse.
 * 	Year: "2006" "06"
 * 	Month: "Jan" "January" "01" "1"
 * 	Day of the week: "Mon" "Monday"
 * 	Day of the month: "2" "_2" "02"
 * 	Day of the year: "__2" "002"
 * 	Hour: "15" "3" "03" (PM or AM)
 * 	Minute: "4" "04"
 * 	Second: "5" "05"
 * 	AM/PM mark: "PM"
 * Numeric time zone offsets format as follows:
 * 	"-0700"     ±hhmm
 * 	"-07:00"    ±hh:mm
 * 	"-07"       ±hh
 * 	"-070000"   ±hhmmss
 * 	"-07:00:00" ±hh:mm:ss
 * Replacing the sign in the format with a Z triggers
 * the ISO 8601 behavior of printing Z instead of an
 * offset for the UTC zone. Thus:
 * 	"Z0700"      Z or ±hhmm
 * 	"Z07:00"     Z or ±hh:mm
 * 	"Z07"        Z or ±hh
 * 	"Z070000"    Z or ±hhmmss
 * 	"Z07:00:00"  Z or ±hh:mm:ss
 * Within the format string, the underscores in "_2" and "__2" represent spaces
 * that may be replaced by digits if the following number has multiple digits,
 * for compatibility with fixed-width Unix time formats. A leading zero represents
 * a zero-padded value.
 * The formats __2 and 002 are space-padded and zero-padded
 * three-character day of year; there is no unpadded day of year format.
 * A comma or decimal point followed by one or more zeros represents
 * a fractional second, printed to the given number of decimal places.
 * A comma or decimal point followed by one or more nines represents
 * a fractional second, printed to the given number of decimal places, with
 * trailing zeros removed.
 * For example "15:04:05,000" or "15:04:05.000" formats or parses with
 * millisecond precision.
 * Some valid layouts are invalid time values for time.Parse, due to formats
 * such as _ for space padding and Z for zone information.
 */
 = "3:04PM"
/**
 * Handy time stamps.
 */
 = "Jan _2 15:04:05"
/**
 * These are predefined layouts for use in Time.Format and time.Parse.
 * The reference time used in these layouts is the specific time stamp:
 * 	01/02 03:04:05PM '06 -0700
 * (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
 * That value is recorded as the constant named Layout, listed below. As a Unix
 * time, this is 1136239445. Since MST is GMT-0700, the reference would be
 * printed by the Unix date command as:
 * 	Mon Jan 2 15:04:05 MST 2006
 * It is a regrettable historic error that the date uses the American convention
 * of putting the numerical month before the day.
 * The example for Time.Format demonstrates the working of the layout string
 * in detail and is a good reference.
 * Note that the RFC822, RFC850, and RFC1123 formats should be applied
 * only to local times. Applying them to UTC times will use "UTC" as the
 * time zone abbreviation, while strictly speaking those RFCs require the
 * use of "GMT" in that case.
 * In general RFC1123Z should be used instead of RFC1123 for servers
 * that insist on that format, and RFC3339 should be preferred for new protocols.
 * RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
 * when used with time.Parse they do not accept all the time formats
 * permitted by the RFCs and they do accept time formats not formally defined.
 * The RFC3339Nano format removes trailing zeros from the seconds field
 * and thus may not sort correctly once formatted.
 * Most programs can use one of the defined constants as the layout passed to
 * Format or Parse. The rest of this comment can be ignored unless you are
 * creating a custom layout string.
 * To define your own format, write down what the reference time would look like
 * formatted your way; see the values of constants like ANSIC, StampMicro or
 * Kitchen for examples. The model is to demonstrate what the reference time
 * looks like so that the Format and Parse methods can apply the same
 * transformation to a general time value.
 * Here is a summary of the components of a layout string. Each element shows by
 * example the formatting of an element of the reference time. Only these values
 * are recognized. Text in the layout string that is not recognized as part of
 * the reference time is echoed verbatim during Format and expected to appear
 * verbatim in the input to Parse.
 * 	Year: "2006" "06"
 * 	Month: "Jan" "January" "01" "1"
 * 	Day of the week: "Mon" "Monday"
 * 	Day of the month: "2" "_2" "02"
 * 	Day of the year: "__2" "002"
 * 	Hour: "15" "3" "03" (PM or AM)
 * 	Minute: "4" "04"
 * 	Second: "5" "05"
 * 	AM/PM mark: "PM"
 * Numeric time zone offsets format as follows:
 * 	"-0700"     ±hhmm
 * 	"-07:00"    ±hh:mm
 * 	"-07"       ±hh
 * 	"-070000"   ±hhmmss
 * 	"-07:00:00" ±hh:mm:ss
 * Replacing the sign in the format with a Z triggers
 * the ISO 8601 behavior of printing Z instead of an
 * offset for the UTC zone. Thus:
 * 	"Z0700"      Z or ±hhmm
 * 	"Z07:00"     Z or ±hh:mm
 * 	"Z07"        Z or ±hh
 * 	"Z070000"    Z or ±hhmmss
 * 	"Z07:00:00"  Z or ±hh:mm:ss
 * Within the format string, the underscores in "_2" and "__2" represent spaces
 * that may be replaced by digits if the following number has multiple digits,
 * for compatibility with fixed-width Unix time formats. A leading zero represents
 * a zero-padded value.
 * The formats __2 and 002 are space-padded and zero-padded
 * three-character day of year; there is no unpadded day of year format.
 * A comma or decimal point followed by one or more zeros represents
 * a fractional second, printed to the given number of decimal places.
 * A comma or decimal point followed by one or more nines represents
 * a fractional second, printed to the given number of decimal places, with
 * trailing zeros removed.
 * For example "15:04:05,000" or "15:04:05.000" formats or parses with
 * millisecond precision.
 * Some valid layouts are invalid time values for time.Parse, due to formats
 * such as _ for space padding and Z for zone information.
 */
 = "Jan _2 15:04:05.000"
/**
 * These are predefined layouts for use in Time.Format and time.Parse.
 * The reference time used in these layouts is the specific time stamp:
 * 	01/02 03:04:05PM '06 -0700
 * (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
 * That value is recorded as the constant named Layout, listed below. As a Unix
 * time, this is 1136239445. Since MST is GMT-0700, the reference would be
 * printed by the Unix date command as:
 * 	Mon Jan 2 15:04:05 MST 2006
 * It is a regrettable historic error that the date uses the American convention
 * of putting the numerical month before the day.
 * The example for Time.Format demonstrates the working of the layout string
 * in detail and is a good reference.
 * Note that the RFC822, RFC850, and RFC1123 formats should be applied
 * only to local times. Applying them to UTC times will use "UTC" as the
 * time zone abbreviation, while strictly speaking those RFCs require the
 * use of "GMT" in that case.
 * In general RFC1123Z should be used instead of RFC1123 for servers
 * that insist on that format, and RFC3339 should be preferred for new protocols.
 * RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
 * when used with time.Parse they do not accept all the time formats
 * permitted by the RFCs and they do accept time formats not formally defined.
 * The RFC3339Nano format removes trailing zeros from the seconds field
 * and thus may not sort correctly once formatted.
 * Most programs can use one of the defined constants as the layout passed to
 * Format or Parse. The rest of this comment can be ignored unless you are
 * creating a custom layout string.
 * To define your own format, write down what the reference time would look like
 * formatted your way; see the values of constants like ANSIC, StampMicro or
 * Kitchen for examples. The model is to demonstrate what the reference time
 * looks like so that the Format and Parse methods can apply the same
 * transformation to a general time value.
 * Here is a summary of the components of a layout string. Each element shows by
 * example the formatting of an element of the reference time. Only these values
 * are recognized. Text in the layout string that is not recognized as part of
 * the reference time is echoed verbatim during Format and expected to appear
 * verbatim in the input to Parse.
 * 	Year: "2006" "06"
 * 	Month: "Jan" "January" "01" "1"
 * 	Day of the week: "Mon" "Monday"
 * 	Day of the month: "2" "_2" "02"
 * 	Day of the year: "__2" "002"
 * 	Hour: "15" "3" "03" (PM or AM)
 * 	Minute: "4" "04"
 * 	Second: "5" "05"
 * 	AM/PM mark: "PM"
 * Numeric time zone offsets format as follows:
 * 	"-0700"     ±hhmm
 * 	"-07:00"    ±hh:mm
 * 	"-07"       ±hh
 * 	"-070000"   ±hhmmss
 * 	"-07:00:00" ±hh:mm:ss
 * Replacing the sign in the format with a Z triggers
 * the ISO 8601 behavior of printing Z instead of an
 * offset for the UTC zone. Thus:
 * 	"Z0700"      Z or ±hhmm
 * 	"Z07:00"     Z or ±hh:mm
 * 	"Z07"        Z or ±hh
 * 	"Z070000"    Z or ±hhmmss
 * 	"Z07:00:00"  Z or ±hh:mm:ss
 * Within the format string, the underscores in "_2" and "__2" represent spaces
 * that may be replaced by digits if the following number has multiple digits,
 * for compatibility with fixed-width Unix time formats. A leading zero represents
 * a zero-padded value.
 * The formats __2 and 002 are space-padded and zero-padded
 * three-character day of year; there is no unpadded day of year format.
 * A comma or decimal point followed by one or more zeros represents
 * a fractional second, printed to the given number of decimal places.
 * A comma or decimal point followed by one or more nines represents
 * a fractional second, printed to the given number of decimal places, with
 * trailing zeros removed.
 * For example "15:04:05,000" or "15:04:05.000" formats or parses with
 * millisecond precision.
 * Some valid layouts are invalid time values for time.Parse, due to formats
 * such as _ for space padding and Z for zone information.
 */
 = "Jan _2 15:04:05.000000"
/**
 * These are predefined layouts for use in Time.Format and time.Parse.
 * The reference time used in these layouts is the specific time stamp:
 * 	01/02 03:04:05PM '06 -0700
 * (January 2, 15:04:05, 2006, in time zone seven hours west of GMT).
 * That value is recorded as the constant named Layout, listed below. As a Unix
 * time, this is 1136239445. Since MST is GMT-0700, the reference would be
 * printed by the Unix date command as:
 * 	Mon Jan 2 15:04:05 MST 2006
 * It is a regrettable historic error that the date uses the American convention
 * of putting the numerical month before the day.
 * The example for Time.Format demonstrates the working of the layout string
 * in detail and is a good reference.
 * Note that the RFC822, RFC850, and RFC1123 formats should be applied
 * only to local times. Applying them to UTC times will use "UTC" as the
 * time zone abbreviation, while strictly speaking those RFCs require the
 * use of "GMT" in that case.
 * In general RFC1123Z should be used instead of RFC1123 for servers
 * that insist on that format, and RFC3339 should be preferred for new protocols.
 * RFC3339, RFC822, RFC822Z, RFC1123, and RFC1123Z are useful for formatting;
 * when used with time.Parse they do not accept all the time formats
 * permitted by the RFCs and they do accept time formats not formally defined.
 * The RFC3339Nano format removes trailing zeros from the seconds field
 * and thus may not sort correctly once formatted.
 * Most programs can use one of the defined constants as the layout passed to
 * Format or Parse. The rest of this comment can be ignored unless you are
 * creating a custom layout string.
 * To define your own format, write down what the reference time would look like
 * formatted your way; see the values of constants like ANSIC, StampMicro or
 * Kitchen for examples. The model is to demonstrate what the reference time
 * looks like so that the Format and Parse methods can apply the same
 * transformation to a general time value.
 * Here is a summary of the components of a layout string. Each element shows by
 * example the formatting of an element of the reference time. Only these values
 * are recognized. Text in the layout string that is not recognized as part of
 * the reference time is echoed verbatim during Format and expected to appear
 * verbatim in the input to Parse.
 * 	Year: "2006" "06"
 * 	Month: "Jan" "January" "01" "1"
 * 	Day of the week: "Mon" "Monday"
 * 	Day of the month: "2" "_2" "02"
 * 	Day of the year: "__2" "002"
 * 	Hour: "15" "3" "03" (PM or AM)
 * 	Minute: "4" "04"
 * 	Second: "5" "05"
 * 	AM/PM mark: "PM"
 * Numeric time zone offsets format as follows:
 * 	"-0700"     ±hhmm
 * 	"-07:00"    ±hh:mm
 * 	"-07"       ±hh
 * 	"-070000"   ±hhmmss
 * 	"-07:00:00" ±hh:mm:ss
 * Replacing the sign in the format with a Z triggers
 * the ISO 8601 behavior of printing Z instead of an
 * offset for the UTC zone. Thus:
 * 	"Z0700"      Z or ±hhmm
 * 	"Z07:00"     Z or ±hh:mm
 * 	"Z07"        Z or ±hh
 * 	"Z070000"    Z or ±hhmmss
 * 	"Z07:00:00"  Z or ±hh:mm:ss
 * Within the format string, the underscores in "_2" and "__2" represent spaces
 * that may be replaced by digits if the following number has multiple digits,
 * for compatibility with fixed-width Unix time formats. A leading zero represents
 * a zero-padded value.
 * The formats __2 and 002 are space-padded and zero-padded
 * three-character day of year; there is no unpadded day of year format.
 * A comma or decimal point followed by one or more zeros represents
 * a fractional second, printed to the given number of decimal places.
 * A comma or decimal point followed by one or more nines represents
 * a fractional second, printed to the given number of decimal places, with
 * trailing zeros removed.
 * For example "15:04:05,000" or "15:04:05.000" formats or parses with
 * millisecond precision.
 * Some valid layouts are invalid time values for time.Parse, due to formats
 * such as _ for space padding and Z for zone information.
 */
 = "Jan _2 15:04:05.000000000"
/**
 * ParseError describes a problem parsing a time string.
 */
export interface ParseError {
  Layout: string;
  Value: string;
  LayoutElem: string;
  ValueElem: string;
  Message: string;
}

//////////
// source: sleep.go

/**
 * Interface to timers implemented in package runtime.
 * Must be in sync with ../runtime/time.go:/^type timer
 */
/**
 * The Timer type represents a single event.
 * When the Timer expires, the current time will be sent on C,
 * unless the Timer was created by AfterFunc.
 * A Timer must be created with NewTimer or AfterFunc.
 */
export interface Timer {
  C: any;
}

//////////
// source: tick.go

/**
 * A Ticker holds a channel that delivers “ticks” of a clock
 * at intervals.
 */
export interface Ticker {
  C: any; // The channel on which the ticks are delivered.
}

//////////
// source: time.go
/*
Package time provides functionality for measuring and displaying time.

The calendrical calculations always assume a Gregorian calendar, with
no leap seconds.

# Monotonic Clocks

Operating systems provide both a “wall clock,” which is subject to
changes for clock synchronization, and a “monotonic clock,” which is
not. The general rule is that the wall clock is for telling time and
the monotonic clock is for measuring time. Rather than split the API,
in this package the Time returned by time.Now contains both a wall
clock reading and a monotonic clock reading; later time-telling
operations use the wall clock reading, but later time-measuring
operations, specifically comparisons and subtractions, use the
monotonic clock reading.

For example, this code always computes a positive elapsed time of
approximately 20 milliseconds, even if the wall clock is changed during
the operation being timed:

	start := time.Now()
	... operation that takes 20 milliseconds ...
	t := time.Now()
	elapsed := t.Sub(start)

Other idioms, such as time.Since(start), time.Until(deadline), and
time.Now().Before(deadline), are similarly robust against wall clock
resets.

The rest of this section gives the precise details of how operations
use monotonic clocks, but understanding those details is not required
to use this package.

The Time returned by time.Now contains a monotonic clock reading.
If Time t has a monotonic clock reading, t.Add adds the same duration to
both the wall clock and monotonic clock readings to compute the result.
Because t.AddDate(y, m, d), t.Round(d), and t.Truncate(d) are wall time
computations, they always strip any monotonic clock reading from their results.
Because t.In, t.Local, and t.UTC are used for their effect on the interpretation
of the wall time, they also strip any monotonic clock reading from their results.
The canonical way to strip a monotonic clock reading is to use t = t.Round(0).

If Times t and u both contain monotonic clock readings, the operations
t.After(u), t.Before(u), t.Equal(u), and t.Sub(u) are carried out
using the monotonic clock readings alone, ignoring the wall clock
readings. If either t or u contains no monotonic clock reading, these
operations fall back to using the wall clock readings.

On some systems the monotonic clock will stop if the computer goes to sleep.
On such a system, t.Sub(u) may not accurately reflect the actual
time that passed between t and u.

Because the monotonic clock reading has no meaning outside
the current process, the serialized forms generated by t.GobEncode,
t.MarshalBinary, t.MarshalJSON, and t.MarshalText omit the monotonic
clock reading, and t.Format provides no format for it. Similarly, the
constructors time.Date, time.Parse, time.ParseInLocation, and time.Unix,
as well as the unmarshalers t.GobDecode, t.UnmarshalBinary.
t.UnmarshalJSON, and t.UnmarshalText always create times with
no monotonic clock reading.

The monotonic clock reading exists only in Time values. It is not
a part of Duration values or the Unix times returned by t.Unix and
friends.

Note that the Go == operator compares not just the time instant but
also the Location and the monotonic clock reading. See the
documentation for the Time type for a discussion of equality
testing for Time values.

For debugging, the result of t.String does include the monotonic
clock reading if present. If t != u because of different monotonic clock readings,
that difference will be visible when printing t.String() and u.String().
*/

/**
 * A Time represents an instant in time with nanosecond precision.
 * Programs using times should typically store and pass them as values,
 * not pointers. That is, time variables and struct fields should be of
 * type time.Time, not *time.Time.
 * A Time value can be used by multiple goroutines simultaneously except
 * that the methods GobDecode, UnmarshalBinary, UnmarshalJSON and
 * UnmarshalText are not concurrency-safe.
 * Time instants can be compared using the Before, After, and Equal methods.
 * The Sub method subtracts two instants, producing a Duration.
 * The Add method adds a Time and a Duration, producing a Time.
 * The zero value of type Time is January 1, year 1, 00:00:00.000000000 UTC.
 * As this time is unlikely to come up in practice, the IsZero method gives
 * a simple way of detecting a time that has not been initialized explicitly.
 * Each Time has associated with it a Location, consulted when computing the
 * presentation form of the time, such as in the Format, Hour, and Year methods.
 * The methods Local, UTC, and In return a Time with a specific location.
 * Changing the location in this way changes only the presentation; it does not
 * change the instant in time being denoted and therefore does not affect the
 * computations described in earlier paragraphs.
 * Representations of a Time value saved by the GobEncode, MarshalBinary,
 * MarshalJSON, and MarshalText methods store the Time.Location's offset, but not
 * the location name. They therefore lose information about Daylight Saving Time.
 * In addition to the required “wall clock” reading, a Time may contain an optional
 * reading of the current process's monotonic clock, to provide additional precision
 * for comparison or subtraction.
 * See the “Monotonic Clocks” section in the package documentation for details.
 * Note that the Go == operator compares not just the time instant but also the
 * Location and the monotonic clock reading. Therefore, Time values should not
 * be used as map or database keys without first guaranteeing that the
 * identical Location has been set for all values, which can be achieved
 * through use of the UTC or Local method, and that the monotonic clock reading
 * has been stripped by setting t = t.Round(0). In general, prefer t.Equal(u)
 * to t == u, since t.Equal uses the most accurate comparison available and
 * correctly handles the case when only one of its arguments has a monotonic
 * clock reading.
 */
export interface Time {
}
/**
 * A Month specifies a month of the year (January = 1, ...).
 */
export type Month = number /* int */;
January = 1,
 = 2
 = 3
 = 4
 = 5
 = 6
 = 7
 = 8
 = 9
 = 10
 = 11
 = 12
/**
 * A Weekday specifies a day of the week (Sunday = 0, ...).
 */
export type Weekday = number /* int */;
Sunday = 0,
 = 1
 = 2
 = 3
 = 4
 = 5
 = 6
/**
 * A Duration represents the elapsed time between two instants
 * as an int64 nanosecond count. The representation limits the
 * largest representable duration to approximately 290 years.
 */
export type Duration = number /* int64 */;
/**
 * Common durations. There is no definition for units of Day or larger
 * to avoid confusion across daylight savings time zone transitions.
 * To count the number of units in a Duration, divide:
 * 	second := time.Second
 * 	fmt.Print(int64(second/time.Millisecond)) // prints 1000
 * To convert an integer number of units to a Duration, multiply:
 * 	seconds := 10
 * 	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s
 */
Nanosecond = 1,
/**
 * Common durations. There is no definition for units of Day or larger
 * to avoid confusion across daylight savings time zone transitions.
 * To count the number of units in a Duration, divide:
 * 	second := time.Second
 * 	fmt.Print(int64(second/time.Millisecond)) // prints 1000
 * To convert an integer number of units to a Duration, multiply:
 * 	seconds := 10
 * 	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s
 */
 = 1000 * Nanosecond
/**
 * Common durations. There is no definition for units of Day or larger
 * to avoid confusion across daylight savings time zone transitions.
 * To count the number of units in a Duration, divide:
 * 	second := time.Second
 * 	fmt.Print(int64(second/time.Millisecond)) // prints 1000
 * To convert an integer number of units to a Duration, multiply:
 * 	seconds := 10
 * 	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s
 */
 = 1000 * Microsecond
/**
 * Common durations. There is no definition for units of Day or larger
 * to avoid confusion across daylight savings time zone transitions.
 * To count the number of units in a Duration, divide:
 * 	second := time.Second
 * 	fmt.Print(int64(second/time.Millisecond)) // prints 1000
 * To convert an integer number of units to a Duration, multiply:
 * 	seconds := 10
 * 	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s
 */
 = 1000 * Millisecond
/**
 * Common durations. There is no definition for units of Day or larger
 * to avoid confusion across daylight savings time zone transitions.
 * To count the number of units in a Duration, divide:
 * 	second := time.Second
 * 	fmt.Print(int64(second/time.Millisecond)) // prints 1000
 * To convert an integer number of units to a Duration, multiply:
 * 	seconds := 10
 * 	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s
 */
 = 60 * Second
/**
 * Common durations. There is no definition for units of Day or larger
 * to avoid confusion across daylight savings time zone transitions.
 * To count the number of units in a Duration, divide:
 * 	second := time.Second
 * 	fmt.Print(int64(second/time.Millisecond)) // prints 1000
 * To convert an integer number of units to a Duration, multiply:
 * 	seconds := 10
 * 	fmt.Print(time.Duration(seconds)*time.Second) // prints 10s
 */
 = 60 * Minute

//////////
// source: zoneinfo.go

/**
 * A Location maps time instants to the zone in use at that time.
 * Typically, the Location represents the collection of time offsets
 * in use in a geographical area. For many Locations the time offset varies
 * depending on whether daylight savings time is in use at the time instant.
 */
export interface Location {
}
/**
 * A zone represents a single time zone such as CET.
 */
/**
 * A zoneTrans represents a single time zone transition.
 */
/**
 * ruleKind is the kinds of rules that can be seen in a tzset string.
 */
/**
 * rule is a rule read from a tzset string.
 */

//////////
// source: zoneinfo_read.go

/**
 * maxFileSize is the max permitted size of files read by readFile.
 * As reference, the zoneinfo.zip distributed by Go is ~350 KB,
 * so 10MB is overkill.
 */
/**
 * Simple I/O interface to binary blob of data.
 */
/**
 * six big-endian 32-bit integers:
 * 	number of UTC/local indicators
 * 	number of standard/wall indicators
 * 	number of leap seconds
 * 	number of transition times
 * 	number of local time zones
 * 	number of characters of time zone abbrev strings
 */
 = 0
/**
 * six big-endian 32-bit integers:
 * 	number of UTC/local indicators
 * 	number of standard/wall indicators
 * 	number of leap seconds
 * 	number of transition times
 * 	number of local time zones
 * 	number of characters of time zone abbrev strings
 */
 = 1
/**
 * six big-endian 32-bit integers:
 * 	number of UTC/local indicators
 * 	number of standard/wall indicators
 * 	number of leap seconds
 * 	number of transition times
 * 	number of local time zones
 * 	number of characters of time zone abbrev strings
 */
 = 2
/**
 * six big-endian 32-bit integers:
 * 	number of UTC/local indicators
 * 	number of standard/wall indicators
 * 	number of leap seconds
 * 	number of transition times
 * 	number of local time zones
 * 	number of characters of time zone abbrev strings
 */
 = 3
/**
 * six big-endian 32-bit integers:
 * 	number of UTC/local indicators
 * 	number of standard/wall indicators
 * 	number of leap seconds
 * 	number of transition times
 * 	number of local time zones
 * 	number of characters of time zone abbrev strings
 */
 = 4
/**
 * six big-endian 32-bit integers:
 * 	number of UTC/local indicators
 * 	number of standard/wall indicators
 * 	number of leap seconds
 * 	number of transition times
 * 	number of local time zones
 * 	number of characters of time zone abbrev strings
 */
 = 5
